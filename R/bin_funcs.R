# From George White's primary production scripts.
#' Generate start bin vector
#'
#' This generates a vector of bin numbers at the start of each row on a global grid, given the number of rows.
#' Example: For 4km resolution, 4320 rows; for 9km resolution, 2160 rows
#'
#' @param nrows Number of rows in the resulting global raster of bin numbers.
#' @return Numeric vector of starting bins.
#' @export
gen_start_bin = function(nrows=4320) {
    latbins = (seq(1:nrows)-0.5)*180/nrows - 90
    numbins = floor(2*nrows*cos(latbins*pi/180.0) + 0.5)
    return(cumsum(c(1,numbins[1:nrows-1])))
}


# From George White's primary production scripts.
#' Generate bin grid
#'
#' This generates a raster of bin numbers based on the bin numbers at the start of each row.
#' Note that the latitudes in the array go from +90 to -90, while the start_num vector goes from -90 to 90.
#'
#' @param start_num Vector of numbers for the bins at the start of each row, generated by gen_start_bin().
#' @return Global raster containing bin numbers.
#' @export
gen_bin_grid = function(start_num) {
    nrow = length(start_num)
    snum = c(start_num, start_num[nrow]+3)
    ncol = 2*nrow
    bins.rl = raster::raster(ncols=ncol, nrows=nrow, xmn=-180, xmx=180, ymn=-90, ymx=90)
    bins = integer(ncol*nrow)
    dim(bins) = c(nrow, ncol)
    for (ilat in 1:nrow) {
        bb1 = start_num[ilat+1]
        bb0 = start_num[ilat]
        nb = bb1 - bb0
        bins[1+nrow-ilat,] = bb0 + floor(seq(0, ncol-1)*nb/ncol)
    }
    raster::values(bins.rl) = bins
    return(bins.rl)
}



# From George White's primary production scripts.
#' Generate raster of L3b data
#'
#' Given a dataframe with 2 columns (bin number and variable), create the corresponding raster for visualization.
#'
#' As of 2022-10-12, this function combines the code from gen_start_bin() and gen_bin_grid() in order to speed it up by subsetting it by latitude.
#'
#' @param df Dataframe with 2 columns: first column="bin" and second column is the variable name (note: the dataframe does not have to be sorted in order of bin number).
#' @param resolution String, either "4km" or "9km".
#' @param ext Named vector containing the boundaries of the resulting grid (xmn, xmx, ymn, ymx).
#' @references See https://oceancolor.gsfc.nasa.gov/docs/format/l3bins/ for more information on bin numbers.
#' @return Raster containing the variable data.
#' @export
var_to_rast <- function(df, resolution="4km", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86)) {

    # get the number of rows on the global grid, given a spatial resolution
    nrows_all_res <- list(`1km` = 17280, `4km` = 4320, `9km` = 2160, `111km` = 180)
    nrows_all <- nrows_all_res[[resolution]]

    # get a vector of latitudes from -90 to 90 degrees (note: latitudes and bins here start in the southeast), and subset to the selected extent
    latitudes <- (seq(1:nrows_all) - 0.5) * 180/nrows_all - 90
    lat_inds <- which(dplyr::between(latitudes, lats[1], lats[2]))

    # get number of columns for the global grid
    ncol <- 2 * nrows_all

    # subset number of rows based on selected extent
    nrows <- length(lat_inds)
    # add an extra index for subsetting vectors later (otherwise they'll be NA at the last index)
    lat_inds <- c(lat_inds,max(lat_inds)+1)

    # get the number of bins per row
    bin_count <- floor(2 * nrows_all * cos(latitudes * pi/180) + 0.5)
    # get the bin at the start of each row, and subset it to the selected extent
    start_bin <- cumsum(c(1, bin_count[1:nrows_all - 1]))[lat_inds]

    # create a blank raster for bins and for the variable
    binGrid <- datGrid <- raster::raster(ncols=ncol, nrows=nrows, xmn=-180, xmx=180, ymn=lats[1], ymx=lats[2])

    # fill the bin numbers in on each row
    # note that to make the grid square, some bins are repeated instead of stretching them
    bins <- integer(ncol * nrows)
    dim(bins) <- c(nrows, ncol)
    bins <- lapply(nrows:1, function(ilat) {
        bb1 <- start_bin[ilat + 1]
        bb0 <- start_bin[ilat]
        bb0 + floor(seq(0, ncol-1) * (bb1-bb0)/ncol)
    })
    bins <- do.call(rbind, bins)

    # put the bin numbers in the bin raster
    raster::values(binGrid) = bins

    # crop bin raster and blank raster to selected extent
    binGrid <- raster::crop(binGrid, raster::extent(ext))
    datGrid <- raster::crop(datGrid, raster::extent(ext))

    # create blank vector of appropriate length (starting bin number of last row + 3 for the 3 bins in the last row)
    data.vc <- rep(NA, times = diff(range(bins,na.rm=TRUE)))
    # populate the chosen bin indices with data
    min_bins <- min(bins,na.rm=TRUE)
    data.vc[df[, 1]-min_bins+1] <- as.numeric(df[, 2])
    # populate the blank raster layer
    raster::values(datGrid) <- data.vc[raster::getValues(binGrid)-min_bins+1]
    names(datGrid) <- colnames(df)[2]

    return(datGrid)

}

#' Get bin info at 4km and 9km resolution
#'
#' Get corresponding bin number, latitude, longitude and depth for Pan-Canadian Grid or subregions
#'
#' @param region String, either "pancan", "nwa", "nep", or "gosl"
#' @param resolution String, either "4km" or "9km".
#' @param variables String with columns: blank or "all" for all columns, or a subset of c("bin","longitude","latitude","bathymetry")
#' @return Data frame with columns of bin, longitude, latitude, bathymetry
#' @examples
#' library(dplyr)
#' library(ggplot2)
#' library(oceancolouR)
#'
#' pancan_bins_4km <- get_bins()
#'
#' # Map of the North West Atlantic bin bathymetry
#' get_bins(region = "nwa", resolution = "9km") %>%
#' ggplot(aes(x = longitude, y = latitude, colour = bathymetry)) +
#'    geom_point(size = 0.5) +
#'    scale_colour_gradientn(colours = pals::ocean.deep(30))
#' @export
#'
get_bins <- function(region = "pancan", resolution = "4km", variables = "all") {
    reginfo = paste0(region,"_",resolution)
    # bins <- (function(v) get(data(list=reginfo)))(reginfo)
    bins <- (function(v) get(data(list=reginfo, package="oceancolouR", envir = new.env())))(reginfo)
    if (any(variables != "all")) {
        bins = bins[,which(names(bins) %in% variables)]
    }
    return(bins)
}

#' Plot panCanadian L3b file
#'
#' Given a vector of data from a binned ocean colour file, plot it on a raster with coastlines.
#'
#' This is used to get a quick look at a file from the panCanadian dataset, before manipulating the data. When the data is loaded, it's in vector format and in the same order as the bin vectors pancan_bins_4km, nwa_bins_4km, etc...
#'
#' @param vec Numeric vector of data (must be in the same order as the the bins vector of the same resolution, whether pancan, nwa, nep, or gosl - see details).
#' @param region String, either "pancan", "nwa", "nep", or "gosl"
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @param resolution String, either "4km" or "9km".
#' @param limits Limits of the colour scale (numeric vector, length 2).
#' @return Raster containing variable values with coastlines.
#' @examples
#' # This is an example file with data in the same format as in a panCanadian dataset file.
#' data("example01_A2018252.L3b_DAY_CHL_POLY4_NWA")
#' dat <- example01_A2018252.L3b_DAY_CHL_POLY4_NWA
#' lon_lim <- lon_bounds[["NWA"]]
#' lat_lim <- lat_bounds[["NWA"]]
#' plot_pancan(log10(dat), region="nwa", ext=c(range(lon_lim),range(lat_lim)))
#'
#' @export
plot_pancan <- function(vec, region="pancan", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86), resolution="4km", limits=NULL) {
    bins <- (function(v) get(data(list=v, package="oceancolouR", envir = new.env())))(paste0(region,"_bins_",resolution))
    rast <- var_to_rast(data.frame(bin=bins, var=vec), resolution=resolution, ext=ext)
    p <- make_raster_map(rast,xlim=ext[1:2],ylim=ext[3:4],col_limits=limits)
    return(p)
}

#' Condense a matrix by averaging selected columns
#'
#' Given a matrix and a list where each element contains a numeric vector of the column indices to average, calculate a condensed matrix.
#'
#' This can be used to take a matrix where rows = pixels and columns = days of the year, and average columns over 8day or month intervals to return, for example, a corresponding matrix of row=pixels and columns=weeks (where a "week" is 8days).
#'
#' @param mat Numeric matrix
#' @param dlist List of numeric vectors, where each vector contains the column indices that should be merged (see example). If left blank, mat must be in order and have no gaps (i.e. a day with no data should be a column of all NA), and a year and "composite" are also required so that dlist can be automatically calculated using the 8day or monthly system.
#' @param year Integer, only needed if dlist is NULL
#' @param composite String, length of output composite, 8day or monthly (only needed if dlist is NULL)
#' @return Numeric matrix with the same number of rows, and the number of columns equal to the length of dlist
#' @examples
#' mat <- matrix(runif(30), nrow=3)
#' avg_columns(mat, dlist=list(1:5, 6:8))
#'
#' @export
avg_columns <- function(mat, dlist=NULL, year=NULL, composite="8day") {

    if (is.null(dlist)) {
        stopifnot(!is.null(year) & composite %in% c("8day", "monthly"))
        last_day <- ncol(mat)
        if (composite=="8day") {
            dlist <- lapply(1:46, function(x) {tmp <- days_vector(year=year, week=x); tmp[tmp <= last_day]})
            dlist <- dlist[sapply(dlist, length) > 0]
        } else if (composite=="monthly") {
            dlist <- lapply(1:12, function(x) {tmp <- days_vector(year=year, month=x); tmp[tmp <= last_day]})
            dlist <- dlist[sapply(dlist, length) > 0]
        }
    }

    new_mat <- lapply(1:length(dlist), function(x) {rowMeans(matrix(mat[,dlist[[x]]],nrow=nrow(mat)), na.rm=TRUE)})
    mat <- do.call(cbind, new_mat)

    return(mat)

}



#' Get bin, longitude, latitude
#'
#' This creates a dataframe containing the bin number, longitude, and latitudes for the full globe, for a given resolution (4.64km, 9.28km, or 111km), using the Integerized Sinusoidal Binning Scheme used by NASA OBPG for their level-3 binned satellite files (e.g. MODIS-Aqua). More info here: https://oceancolor.gsfc.nasa.gov/docs/format/l3bins/
#'
#' WARNING: This retrieves ALL bins, over both land and water. The pre-made bin vectors for pancan/nwa/nep/gosl regions that are retrieved by the get_bins() function only include bins over water.
#'
#' @param resolution Spatial resolution for binned grid (either 1km, 4km, 9km, or 111km)
#' @param lonlim Minimum and maximum longitude of the area of interest
#' @param latlim Minimum and maximum latitude of the area of interest
#' @return Dataframe with 3 columns: bin, longitude, latitude
#' @export
binlatlon <- function(resolution="4km", lonlim=c(-180,180), latlim=c(-90,90)) {

    stopifnot(resolution %in% paste0(c(1,4,9,111),"km"))

    # get number of rows, given a spatial resolution
    nrows_all <- list("1km"=17280, "4km"=4320, "9km"=2160, "111km"=180)
    nrows <- nrows_all[[resolution]]

    # get the latitude for each row, and the number of bins per row
    latitudes <- (seq(1:nrows)-0.5)*180/nrows - 90
    bin_count <- floor(2*nrows*cos(latitudes*pi/180.0) + 0.5)
    start_bins <- cumsum(bin_count)

    # get the distance between each bin in each row
    minlon <- -180
    maxlon <- 180
    londiff <- (maxlon - minlon) / bin_count

    # subset to only the rows within the selected latitudes
    lat_inds <- dplyr::between(latitudes, latlim[1], latlim[2])
    latitudes <- latitudes[lat_inds]
    bin_count <- bin_count[lat_inds]
    londiff <- londiff[lat_inds]
    lat_inds_range <- range(which(lat_inds))
    start_bins <- start_bins[(lat_inds_range[1]-1):lat_inds_range[2]]
    bin_nums <- (start_bins[1]+1):start_bins[length(start_bins)]

    # get a vector of longitudes for each row
    longitudes <- lapply(1:length(latitudes), function(i) {
        diff <- londiff[i]
        seq(from=(minlon+(diff/2)), to=(maxlon-(diff/2)), by=diff)
    })
    longitudes <- do.call(c, longitudes)

    # expand latitude vector to the same length as the longitude vector,
    # then subset to the selected longitudes
    lon_inds <- dplyr::between(longitudes, lonlim[1], lonlim[2])
    longitudes <- longitudes[lon_inds]
    latitudes <- rep(latitudes, bin_count)[lon_inds]
    bin_nums <- bin_nums[lon_inds]

    return(data.frame(bin = bin_nums,
                      longitude = longitudes,
                      latitude = latitudes,
                      stringsAsFactors = FALSE))

}
