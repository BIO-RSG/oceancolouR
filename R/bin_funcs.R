# From George White's primary production scripts.
#' Generate start bin vector
#'
#' This generates a vector of bin numbers at the start of each row on a global grid, given the number of rows.
#' Example: For 4km resolution, 4320 rows; for 9km resolution, 2160 rows
#'
#' @param nrows Number of rows in the resulting global raster of bin numbers.
#' @return Numeric vector of starting bins.
#' @export
gen_start_bin = function(nrows=4320) {
    latbins = (seq(1:nrows)-0.5)*180/nrows - 90
    numbins = floor(2*nrows*cos(latbins*pi/180.0) + 0.5)
    return(cumsum(c(1,numbins[1:nrows-1])))
}


# From George White's primary production scripts.
#' Generate bin grid
#'
#' This generates a raster of bin numbers based on the bin numbers at the start of each row.
#' Note that the latitudes in the array go from +90 to -90, while the start_num vector goes from -90 to 90.
#'
#' @param start_num Vector of numbers for the bins at the start of each row, generated by gen_start_bin().
#' @return Global raster containing bin numbers.
#' @export
gen_bin_grid = function(start_num) {
    nrow = length(start_num)
    snum = c(start_num, start_num[nrow]+3)
    ncol = 2*nrow
    bins.rl = raster::raster(ncols=ncol, nrows=nrow, xmn=-180, xmx=180, ymn=-90, ymx=90)
    bins = integer(ncol*nrow)
    dim(bins) = c(nrow, ncol)
    for (ilat in 1:nrow) {
        bb1 = start_num[ilat+1]
        bb0 = start_num[ilat]
        nb = bb1 - bb0
        bins[1+nrow-ilat,] = bb0 + floor(seq(0, ncol-1)*nb/ncol)
    }
    raster::values(bins.rl) = bins
    return(bins.rl)
}



# From George White's primary production scripts.
#' Generate raster of L3b data
#'
#' Create 2d grid of a variable, given a dataframe with 2 columns, one for bin numbers and one for variable values.
#'
#' @param df Dataframe with 2 columns: bin numbers, and variable values.
#' @param resolution String, either "4km" or "9km".
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @return Global raster containing variable values.
#' @export
var_to_rast <- function(df, resolution="4km", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86)) {

    # create global grid of bin numbers at selected resolution
    if (resolution=="4km") {
        start_num <- gen_start_bin(4320)
    } else if (resolution=="9km") {
        start_num <- gen_start_bin(2160)
    }
    binGrid <- gen_bin_grid(start_num)

    # create blank global raster at selected resolution
    nrows <- length(start_num)
    data.rl <- raster::raster(nrows=nrows, ncols=(2*nrows))

    # crop bin raster and blank raster to user-selected extent
    binGrid <- raster::crop(binGrid, raster::extent(ext))
    data.rl <- raster::crop(data.rl, raster::extent(ext))

    # create blank vector of appropriate length (starting bin number of last row + 3 for the 3 bins in the last row)
    data.vc <- rep(NA, times=start_num[nrows]+3)
    # populate the chosen bin indices with data
    data.vc[df[,1]] <- as.numeric(df[,2])
    # populate the blank raster layer
    raster::values(data.rl) <- data.vc[raster::getValues(binGrid)]
    names(data.rl) <- colnames(df)[2]

    return(data.rl)

}


#' Plot panCanadian L3b file
#'
#' Given a vector of data from a binned panCanadian ocean colour file, plot it on a raster with coastlines.
#'
#' @param vec Numeric vector of data.
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @param resolution String, either "4km" or "9km".
#' @param limits Limits of the colour scale (numeric vector, length 2).
#' @return Raster containing variable values with coastlines.
#' @export
plot_rast_from_bin <- function(vec, ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86), resolution="4km", limits=c(-Inf, Inf)) {
    data("wrld_simpl", package = "maptools")
    if (resolution=="4km") {
        data("pancan_bins_4km", package = "oceancolouR")
        bins <- pancan_bins_4km
    } else if (resolution=="9km") {
        data("pancan_bins_9km", package = "oceancolouR")
        bins <- pancan_bins_9km
    }
    rast <- var_to_rast(data.frame(bin=bins, var=vec), resolution=resolution, ext=ext)
    return(raster::spplot(raster::crop(rast, raster::extent(ext)), zlim=limits) + latticeExtra::layer(sp::sp.polygons(wrld_simpl)))
}


#' Group daily bin matrix as 8day or monthly
#'
#' Input a matrix where rows = binned pixels and columns = days of the year, and use rowMeans to condense the columns to 8day or monthly composites, resulting in a matrix of (binned pixels) x (months), for example. Note that a day that has no valid data should be a column of all NA, but if consecutive days are missing from the end of the year (for example, if the data hasn't been made available yet), those columns could be excluded. Example: If the dataset for 2020 ends at day 321 (Nov. 16th), and you're using the panCanadian grid which has 529797 pixels, the matrix should have dimensions 529797 x 321.
#'
#' @param mat Numeric matrix where rows=binned pixels and columns=days of the year (in order, with no gaps - if a day has no data, it should be a column of all NA)
#' @param composite String, length of output composite, 8day or monthly
#' @return Numeric matrix where rows = binned pixels, columns = weeks (8day) or months
#' @export
convert_daily_grid <- function(mat, composite="8day") {

    last_day <- ncol(mat)

    if (composite=="8day") {
        dlist <- lapply(1:46, function(x) {tmp <- days_vector(year=year, week=x); tmp[tmp <= last_day]})
        dlist <- dlist[sapply(dlist, length) > 0]
    } else if (composite=="monthly") {
        dlist <- lapply(1:12, function(x) {tmp <- days_vector(year=year, month=x); tmp[tmp <= last_day]})
        dlist <- dlist[sapply(dlist, length) > 0]
    }

    new_mat <- lapply(1:length(dlist), function(x) {rowMeans(mat[,dlist[[x]]], na.rm=TRUE)})
    mat <- do.call(cbind, new_mat)

    return(mat)

}
