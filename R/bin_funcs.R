# From George White's primary production scripts.
#' Generate start bin vector
#'
#' This generates a vector of bin numbers at the start of each row on a global grid, given the number of rows.
#' Example: For 4km resolution, 4320 rows; for 9km resolution, 2160 rows
#'
#' @param nrows Number of rows in the resulting global raster of bin numbers.
#' @return Numeric vector of starting bins.
#' @export
gen_start_bin = function(nrows=4320) {
    latbins = (seq(1:nrows)-0.5)*180/nrows - 90
    numbins = floor(2*nrows*cos(latbins*pi/180.0) + 0.5)
    return(cumsum(c(1,numbins[1:nrows-1])))
}


# From George White's primary production scripts.
#' Generate bin grid
#'
#' This generates a raster of bin numbers based on the bin numbers at the start of each row.
#' Note that the latitudes in the array go from +90 to -90, while the start_num vector goes from -90 to 90.
#'
#' @param start_num Vector of numbers for the bins at the start of each row, generated by gen_start_bin().
#' @return Global raster containing bin numbers.
#' @export
gen_bin_grid = function(start_num) {
    nrow = length(start_num)
    snum = c(start_num, start_num[nrow]+3)
    ncol = 2*nrow
    bins.rl = raster::raster(ncols=ncol, nrows=nrow, xmn=-180, xmx=180, ymn=-90, ymx=90)
    bins = integer(ncol*nrow)
    dim(bins) = c(nrow, ncol)
    for (ilat in 1:nrow) {
        bb1 = start_num[ilat+1]
        bb0 = start_num[ilat]
        nb = bb1 - bb0
        bins[1+nrow-ilat,] = bb0 + floor(seq(0, ncol-1)*nb/ncol)
    }
    raster::values(bins.rl) = bins
    return(bins.rl)
}



# From George White's primary production scripts.
#' Generate raster of L3b data
#'
#' Create 2d grid of a variable, given a dataframe with 2 columns, one for bin numbers and one for variable values.
#'
#' @param df Dataframe with 2 columns: bin numbers, and variable values (note: the dataframe does not have to be in order of bin number).
#' @param resolution String, either "4km" or "9km".
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @return Global raster containing variable values.
#' @export
var_to_rast <- function(df, resolution="4km", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86)) {

    # create global grid of bin numbers at selected resolution
    if (resolution=="4km") {
        start_num <- gen_start_bin(4320)
    } else if (resolution=="9km") {
        start_num <- gen_start_bin(2160)
    }
    binGrid <- gen_bin_grid(start_num)

    # create blank global raster at selected resolution
    nrows <- length(start_num)
    data.rl <- raster::raster(nrows=nrows, ncols=(2*nrows))

    # crop bin raster and blank raster to user-selected extent
    binGrid <- raster::crop(binGrid, raster::extent(ext))
    data.rl <- raster::crop(data.rl, raster::extent(ext))

    # create blank vector of appropriate length (starting bin number of last row + 3 for the 3 bins in the last row)
    data.vc <- rep(NA, times=start_num[nrows]+3)
    # populate the chosen bin indices with data
    data.vc[df[,1]] <- as.numeric(df[,2])
    # populate the blank raster layer
    raster::values(data.rl) <- data.vc[raster::getValues(binGrid)]
    names(data.rl) <- colnames(df)[2]

    return(data.rl)

}

#' Get bin info at 4km and 9km resolution
#'
#' Get corresponding bin number, latitude, longitude and depth for Pan-Canadian Grid or subregions
#'
#' @param region String, either "pancan", "nwa", "nep", or "gosl"
#' @param resolution String, either "4km" or "9km".
#' @param variables String with columns: blank or "all" for all columns, or a subset of c("bin","longitude","latitude","bathymetry")
#' @return Data frame with columns of bin, longitude, latitude, bathymetry
#' @examples
#' library(dplyr)
#' library(ggplot2)
#' library(oceancolouR)
#'
#' pancan_bins_4km <- get_bins()
#'
#' # Map of the North West Atlantic bin bathymetry
#' get_bins(region = "nwa", resolution = "9km") %>%
#' ggplot(aes(x = longitude, y = latitude, colour = bathymetry)) +
#'    geom_point(size = 0.5) +
#'    scale_colour_gradientn(colours = pals::ocean.deep(30))
#' @export
#'
get_bins <- function(region = "pancan", resolution = "4km", variables = "all") {
    reginfo = paste0(region,"_",resolution)
    # bins <- (function(v) get(data(list=reginfo)))(reginfo)
    bins <- (function(v) get(data(list=reginfo, package="oceancolouR", envir = new.env())))(reginfo)
    if (any(variables != "all")) {
        bins = bins[,which(names(bins) %in% variables)]
    }
    return(bins)
}

#' Plot panCanadian L3b file
#'
#' Given a vector of data from a binned ocean colour file, plot it on a raster with coastlines.
#'
#' This is used to get a quick look at a file from the panCanadian dataset, before manipulating the data. When the data is loaded, it's in vector format and in the same order as the bin vectors pancan_bins_4km, nwa_bins_4km, etc...
#'
#' @param vec Numeric vector of data (must be in the same order as the the bins vector of the same resolution, whether pancan, nwa, nep, or gosl - see details).
#' @param region String, either "pancan", "nwa", "nep", or "gosl"
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @param resolution String, either "4km" or "9km".
#' @param limits Limits of the colour scale (numeric vector, length 2).
#' @return Raster containing variable values with coastlines.
#' @examples
#' # This is an example file with data in the same format as in a panCanadian dataset file.
#' data("example01_A2018252.L3b_DAY_CHL_POLY4_NWA.rda")
#' lon_lim <- lon_bounds[["NWA"]]
#' lat_lim <- lat_bounds[["NWA"]]
#' plot_pancan(log10(dat), region="nwa", ext=c(range(lon_lim),range(lat_lim)))
#'
#' @export
plot_pancan <- function(vec, region="pancan", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86), resolution="4km", limits=NULL) {
    bins <- (function(v) get(data(list=v, package="oceancolouR", envir = new.env())))(paste0(region,"_bins_",resolution))
    rast <- var_to_rast(data.frame(bin=bins, var=vec), resolution=resolution, ext=ext)
    p <- make_raster_map(rast,xlim=ext[1:2],ylim=ext[3:4],col_limits=limits)
    return(p)
}

#' Condense a matrix by averaging selected columns
#'
#' Given a matrix and a list where each element contains a numeric vector of the column indices to average, calculate a condensed matrix.
#'
#' This can be used to take a matrix where rows = pixels and columns = days of the year, and average columns over 8day or month intervals to return, for example, a corresponding matrix of row=pixels and columns=weeks (where a "week" is 8days).
#'
#' @param mat Numeric matrix
#' @param dlist List of numeric vectors, where each vector contains the column indices that should be merged (see example). If left blank, mat must be in order and have no gaps (i.e. a day with no data should be a column of all NA), and a year and "composite" are also required so that dlist can be automatically calculated using the 8day or monthly system.
#' @param year Integer, only needed if dlist is NULL
#' @param composite String, length of output composite, 8day or monthly (only needed if dlist is NULL)
#' @return Numeric matrix with the same number of rows, and the number of columns equal to the length of dlist
#' @examples
#' mat <- matrix(runif(30), nrow=3)
#' avg_columns(mat, dlist=list(1:5, 6:8))
#'
#' @export
avg_columns <- function(mat, dlist=NULL, year=NULL, composite="8day") {

    if (is.null(dlist)) {
        stopifnot(!is.null(year) & composite %in% c("8day", "monthly"))
        last_day <- ncol(mat)
        if (composite=="8day") {
            dlist <- lapply(1:46, function(x) {tmp <- days_vector(year=year, week=x); tmp[tmp <= last_day]})
            dlist <- dlist[sapply(dlist, length) > 0]
        } else if (composite=="monthly") {
            dlist <- lapply(1:12, function(x) {tmp <- days_vector(year=year, month=x); tmp[tmp <= last_day]})
            dlist <- dlist[sapply(dlist, length) > 0]
        }
    }

    new_mat <- lapply(1:length(dlist), function(x) {rowMeans(mat[,dlist[[x]]], na.rm=TRUE)})
    mat <- do.call(cbind, new_mat)

    return(mat)

}
