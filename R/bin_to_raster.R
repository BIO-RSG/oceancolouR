# From George White's primary production scripts.
#' Generate start bin vector
#'
#' This generates a vector of bin numbers at the start of each row on a global grid, given the number of rows.
#' Example: For 4km resolution, 4320 rows; for 9km resolution, 2160 rows
#'
#' @param nrows Number of rows in the resulting global raster of bin numbers.
#' @return Numeric vector of starting bins.
#' @export
gen_start_bin = function(nrows=4320) {
    latbins = (seq(1:nrows)-0.5)*180/nrows - 90
    numbins = floor(2*nrows*cos(latbins*pi/180.0) + 0.5)
    return(cumsum(c(1,numbins[1:nrows-1])))
}


# From George White's primary production scripts.
#' Generate bin grid
#'
#' This generates a raster of bin numbers based on the bin numbers at the start of each row.
#' Note that the latitudes in the array go from +90 to -90, while the start_num vector goes from -90 to 90.
#'
#' @param start_num Vector of numbers for the bins at the start of each row, generated by gen_start_bin().
#' @return Global raster containing bin numbers.
#' @export
gen_bin_grid = function(start_num) {
    nrow = length(start_num)
    snum = c(start_num, start_num[nrow]+3)
    ncol = 2*nrow
    bins.rl = raster::raster(ncols=ncol, nrows=nrow, xmn=-180, xmx=180, ymn=-90, ymx=90)
    bins = integer(ncol*nrow)
    dim(bins) = c(nrow, ncol)
    for (ilat in 1:nrow) {
        bb1 = start_num[ilat+1]
        bb0 = start_num[ilat]
        nb = bb1 - bb0
        bins[1+nrow-ilat,] = bb0 + floor(seq(0, ncol-1)*nb/ncol)
    }
    raster::values(bins.rl) = bins
    return(bins.rl)
}



# From George White's primary production scripts.
#' Generate raster of L3b data
#'
#' Create 2d grid of a variable, given a dataframe with 2 columns, one for bin numbers and one for variable values.
#'
#' @param df Dataframe with 2 columns: bin numbers, and variable values.
#' @param resolution String, either "4km" or "9km".
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @return Global raster containing variable values.
#' @export
var_to_rast <- function(df, resolution="4km", ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86)) {

    # create global grid of bin numbers at selected resolution
    if (resolution=="4km") {
        start_num <- gen_start_bin(4320)
    } else if (resolution=="9km") {
        start_num <- gen_start_bin(2160)
    }
    binGrid <- gen_bin_grid(start_num)

    # create blank global raster at selected resolution
    nrows <- length(start_num)
    data.rl <- raster::raster(nrows=nrows, ncols=(2*nrows))

    # crop bin raster and blank raster to user-selected extent
    binGrid <- raster::crop(binGrid, extent(ext))
    data.rl <- raster::crop(data.rl, extent(ext))

    # create blank vector of appropriate length (starting bin number of last row + 3 for the 3 bins in the last row)
    data.vc <- rep(NA, times=start_num[nrows]+3)
    # populate the chosen bin indices with data
    data.vc[df[,1]] <- as.numeric(df[,2])
    # populate the blank raster layer
    raster::values(data.rl) <- data.vc[raster::getValues(binGrid)]
    names(data.rl) <- colnames(df)[2]

    return(data.rl)

}


#' Plot panCanadian L3b file
#'
#' Given a vector of data from a binned panCanadian ocean colour file, plot it on a raster with coastlines.
#'
#' @param vec Numeric vector of data.
#' @param ext Named vector containing the boundaries of the resulting grid.
#' @param resolution String, either "4km" or "9km".
#' @param limits Limits of the colour scale (numeric vector, length 2).
#' @return Raster containing variable values with coastlines.
#' @export
plot_rast_from_bin <- function(vec, ext=c(xmn=-147, xmx=-41, ymn=39, ymx=86), resolution="4km", limits=c(-Inf, Inf)) {
    data("wrld_simpl", package = "maptools")
    if (resolution=="4km") {
        data("panCanadian_bins_4km")
        bins <- pancan_bins_4km
    } else if (resolution=="9km") {
        data("panCanadian_bins_9km")
        bins <- pancan_bins_9km
    }
    rast <- var_to_rast(data.frame(bin=bins, var=vec), resolution=resolution, ext=ext)
    return(raster::spplot(raster::crop(rast, raster::extent(ext)), zlim=limits) + latticeExtra::layer(sp::sp.polygons(wrld_simpl)))
}
