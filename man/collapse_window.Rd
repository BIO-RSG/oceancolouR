% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_funcs.R
\name{collapse_window}
\alias{collapse_window}
\title{#' Filter in situ / satellite matchups
#'
#' Given a set of in situ / satellite matchups, filter according to the selected criteria for quality control. Square pixel boxes around a satellite pixel are collapsed into a single value to compare to the matching in situ record.
#'
#' Defaults to the criteria used in Bailey/Werdell (2006, see references) - with exceptions (see below):
#'
#' Bailey/Werdell 2006 criteria:
#'    - L2 satellite passes
#'    - flags used: land, cloud or ice, stray light, sun glint, high TOA radiance, low Lwn(555) for identifying cloud-shadowed pixels, or atmospheric correction failure
#'    - some in situ records excluded based on in situ radiances (see paper for details)
#'    - ** use only the single closest satellite match to the in situ sample location
#'    - ** extract 5x5 pixel box around center (matching) pixel
#'    - ** maximum allowed time difference between satellite pass and in situ sampling: +/- 3 hours
#'    - ** at least 50\% of the pixels in the 5x5 pixel box must be valid
#'    - *** median CV (coefficient of variation) of 5x5 box of Lwn (not Rrs) must be <= 0.15
#'    - ** sensor zenith angle < 60 degrees
#'    - ** solar zenith angle < 75 degrees
#'    - ** for 1 in situ record and >1 satellite passes: keep only the record closest in TIME
#'    - *** for >1 in situ records for 1 satellite pass, and in situ records overlap: keep only the record closest in TIME
#'
#' Details:
#'    - ** applied in filter_matchups using defaults
#'    - *** applied in filter_matchups, but details are slightly different:
#'
#'          - if selected, Rrs is filtered by CV instead of filtering Lwn by CV
#'          - some satellite passes might have >2 in situ matchups where all of them overlap; in this case, only the closest match in time is used (Bailey/Werdell compares 2 overlapping matches but it's unclear how to filter >2 matchups in this case)
#'
#' Some filters are automatically applied (not optional):
#'    - duplicate in situ IDs are removed if all other variables are the same
#'    - shallowest in situ record is used, if there are multiple records present for single datetime/lat/lon within max_depth
#'    - for 1 in situ record and 1 satellite pass with multiple matchups, only the closest is used
#'    - for 1 in situ record and >1 satellite passes, only one record is used (either closest in time or space, user-selected)
#'    - records with nonfinite chla (satellite or in situ) removed
#'    - matchups with all nonfinite Rrs removed
#'
#' df formatting requirements:
#'    - Required columns: is_chla, is_lon, is_lat, is_datetime, sat_time
#'    - In situ data columns must start with "is_", and satellite columns must start with "sat_".
#'    - Datetime column should be "is_datetime" and be in the format "YYYY-MM-DD HH:MM:SS", in UTC (or same as satellite pass timezone).
#'    - Satellite pass time column should be "sat_time" and be a numeric value representing seconds since 1970-01-01 UTC.
#'    - If in situ data records have IDs, they should be in column "is_id".
#'    - If in situ data has depth information, it should be in column "is_depth".

#' @param sat_rrs Named list of satellite remote sensing reflectances - each list element must be a matrix containing the reflectances for that waveband, where rows=matchups and columns=pixels (e.g. a flattened 5x5 box around the matching pixel). Names must be in the format Rrs_XXX, where XXX is the waveband in nanometres
#' @param sat_chla Matrix of satellite chla, where rows=matchups and columns=pixels (e.g. a flattened 5x5 box around the matching pixel).
#' @param sat_lat Matrix of satellite latitudes, where rows=matchups and columns=pixels (e.g. a flattened 5x5 box around the matching pixel).
#' @param sat_lon Matrix of satellite longitudes, where rows=matchups and columns=pixels (e.g. a flattened 5x5 box around the matching pixel).
#' @param df Other in situ/satellite matchup data corresponding to the 2d satellite variables above, with matchups in the same order (see details for formatting requirements)
#' @param window_size Integer, size of one side of the pixel box you want to use, must be <= input box size (e.g. if input contains Rrs matchups with 5x5 box around the center pixel, window_size can be <= 5)
#' @param rm_rrs_LE_0 TRUE/FALSE, set satellite Rrs <= 0 to NA?
#' @param rm_chla_LE_0 TRUE/FALSE, set satellite chla <= 0 to NA?
#' @param min_pix Integer, required number of valid pixels in the pixel box (if there are not enough, the match = NA)
#' @param rrsCVfilter TRUE/FALSE, filter matchups by CV (coefficient of variation) in the pixel box?
#' @param max_CV Numeric value, maximum allowed CV if rrsCVfilter=TRUE
#' @param max_sensor_zen Numeric value, maximum allowed sensor zenith angle. Set to Inf to ignore
#' @param max_solar_zen Numeric value, maximum allowed solar zenith angle. Set to Inf to ignore
#' @param rrs_window String (either median, mean, or geomean) - the statistic to use to collapse each Rrs pixel box into one value
#' @param chla_window String (either median, mean, or geomean) - the statistic to use to collapse each chla pixel box into one value
#' @param max_depth Numeric value, maximum allowed depth of in situ measurement (in metres). Set to Inf to ignore
#' @param max_timediff Numeric value, maximum allowed time difference between in situ measurement and satellite pass (in hours). Set to Inf to ignore
#' @param max_dist Numeric value, maximum allowed distance between in situ measurement and satellite pixel (in metres). Set to Inf to ignore
#' @param rm_sat_dup_by String (either timediff or dist) - if one in situ measurement matches to multiple satellite passes, should you keep the pass closest in time or in space?
#' @param rm_insitu_dup TRUE/FALSE - if one satellite pass matches to multiple in situ measurements, and pixel boxes around the measurements overlap (i.e. center pixel of one inside the pixel box of a separate measurement), should you remove all but one of the overlapping records?
#' @param rm_insitu_dup_by String (either timediff or dist) - if rm_insitu_dup=TRUE, should you choose the in situ measurement closest in time or space to the satellite pass/pixel?
#' @param rm_invalid_rrs TRUE/FALSE - remove matches with any invalid Rrs? If FALSE, only matches with no valid Rrs will be removed
#' @references
#' Bailey, Sean & Werdell, Jeremy. (2006). A multi-sensor approach for the on-orbit validation of ocean color satellite data products. Remote Sensing of Environment. 102. 12-23. 10.1016/j.rse.2006.01.015.
#' (See Fig.1)
#' @return df with added columns: satellite Rrs and chla (one Rrs and one chla pixel representing each pixel "window"), latitude/longitude of the center pixel of each pixel window, distance between in situ sample location and center pixel, and time difference between in situ sample and satellite pass.
#' @importFrom magrittr "\%>\%"
#' @export
filter_matchups <- function(sat_rrs, sat_chla, sat_lat, sat_lon, df,
# for filtering satellite values
window_size=5, rm_rrs_LE_0=TRUE, rm_chla_LE_0=TRUE,
min_pix=13, rrsCVfilter=TRUE, max_CV=0.15,
max_sensor_zen=60, max_solar_zen=75,
rrs_window="median", chla_window="median",
# for filtering in situ values
max_depth=10,
# for filtering matchups
max_timediff=3, max_dist=10000,
rm_sat_dup_by="timediff",
rm_insitu_dup=TRUE,
rm_insitu_dup_by="timediff",
rm_invalid_rrs=TRUE) {}
\usage{
collapse_window(
  var,
  input_ws,
  output_ws,
  min_pix,
  useCVfilter = TRUE,
  max_CV = 0.15,
  stat_to_use = "median"
)
}
\arguments{
\item{var}{Numeric vector or square matrix, length input_ws^2}

\item{input_ws}{Integer, length of one side of the input square pixel box}

\item{output_ws}{Integer, length of one side of the output square pixel box (<= input_ws)}

\item{min_pix}{Integer, minimum number of valid pixels required}

\item{useCVfilter}{TRUE/FALSE - if median CV (coefficient of variation, filteredSD/filteredMean) is > max_CV, return NA?}

\item{max_CV}{Maximum allowed CV}

\item{stat_to_use}{String, either median, mean, or geomean - the statistic used on the final filtered set of var}
}
\value{
Single numeric value representing the input window
}
\description{
\if{html}{\out{<div class="sourceCode">}}\preformatted{#***************************************************************************
# STEP 1: run checks on input
}\if{html}{\out{</div>}}
}
\details{

}
